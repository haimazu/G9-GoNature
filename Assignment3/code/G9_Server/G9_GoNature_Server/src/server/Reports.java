package server;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import ocsf.server.ConnectionToClient;

/**
 * The Reports program generates Reports
 *
 * @author Anastasia Kokin
 */

public class Reports {

	// changed by Anastasia for testing
	// only executes the sending to client part
	public static void VisitsReport(ArrayList<Object> recived, ConnectionToClient client) {

		EchoServer.sendToMyClient(getVisitsReportData(recived), client);
	}

	/**
	 * calculate the percentage of people that were in the park for some amount of
	 * time (0 to 1, 1 to 2, 2 to 3, 3 to 4), generated by visitors type. sends to
	 * client: ArrayList of Object cell[0] name cell[1] 0 to 1 percentage of
	 * visitors cell[2] 1 to 2 percentage of visitors cell[3] 2 to 3 percentage of
	 * visitors cell [4] 3 to 4 percentage of visitors.
	 * 
	 * @param recived ArrayList of Object cell[0] calling function name cell[1] from
	 *                date cell[2] to date cell[3] orderType
	 * @param client  ConnectionToClient
	 */
	@SuppressWarnings("unchecked")
	public static ArrayList<Object> getVisitsReportData(ArrayList<Object> recived) {

		ArrayList<Object> answer = new ArrayList<Object>();
		answer.add(recived.get(0));
		ArrayList<String> dataFromClient = (ArrayList<String>) recived.get(1);
		String startDate = (String) dataFromClient.get(0);
		String endDate = (String) dataFromClient.get(1);
		String ot = (String) dataFromClient.get(2);
		String dateCond = "timeEnter BETWEEN '" + startDate + "' AND '" + endDate + "'";

		double[] temp = new double[4];
		int amountArrivedOverall = 0;
		ArrayList<String> query1 = new ArrayList<String>();
		query1.add("select"); // command
		query1.add("enteryandexit"); // table name
		query1.add("SUM(amountArrived)"); // columns to present
		query1.add("WHERE orderType='" + ot.toString() + "' AND " + dateCond + " "
				+ " AND HOUR(TIME(timeExit))- HOUR(TIME(timeEnter)) <=1 "
				+ " AND HOUR(TIME(timeExit)) - HOUR(TIME(timeEnter)) > 0"); // condition
		query1.add("1"); // how many columns returned

		ArrayList<ArrayList<String>> queryData1 = MySQLConnection.select(query1);

		if (queryData1 == null)
			return null;
		if (!(queryData1.get(0).get(0) == null)) {
			temp[0] = Double.parseDouble(queryData1.get(0).get(0));
			amountArrivedOverall += temp[0];
		} else
			temp[0] = 0;

		ArrayList<String> query2 = new ArrayList<String>();
		query2.add("select"); // command
		query2.add("enteryandexit"); // table name
		query2.add("SUM(amountArrived)"); // columns to present
		query2.add("WHERE orderType='" + ot.toString() + "' AND " + dateCond + " "
				+ " AND HOUR(TIME(timeExit)) - HOUR(TIME(timeEnter)) <= 2  "
				+ " AND HOUR(TIME(timeExit)) - HOUR(TIME(timeEnter)) > 1"); // condition
		query2.add("1"); // how many columns returned

		ArrayList<ArrayList<String>> queryData2 = MySQLConnection.select(query2);
		if (!(queryData2.get(0).get(0) == null)) {
			temp[1] = Double.parseDouble(queryData2.get(0).get(0));
			amountArrivedOverall += temp[1];
		} else
			temp[1] = 0;

		ArrayList<String> query3 = new ArrayList<String>();
		query3.add("select"); // command
		query3.add("enteryandexit"); // table name
		query3.add("SUM(amountArrived)"); // columns to present
		query3.add("WHERE orderType='" + ot.toString() + "' AND " + dateCond + " "
				+ " AND HOUR(TIME(timeExit)) - HOUR(TIME(timeEnter)) <= 3 "
				+ " AND HOUR(TIME(timeExit)) - HOUR(TIME(timeEnter)) > 2"); // condition
		query3.add("1"); // how many columns returned

		ArrayList<ArrayList<String>> queryData3 = MySQLConnection.select(query3);

		if (!(queryData3.get(0).get(0) == null)) {
			temp[2] = Double.parseDouble(queryData3.get(0).get(0));
			amountArrivedOverall += temp[2];
		} else
			temp[2] = 0;

		ArrayList<String> query4 = new ArrayList<String>();
		query4.add("select"); // command
		query4.add("enteryandexit"); // table name
		query4.add("SUM(amountArrived)"); // columns to present
		query4.add("WHERE orderType='" + ot.toString() + "' AND " + dateCond + " "
				+ " AND HOUR(TIME(timeExit)) - HOUR(TIME(timeEnter)) <=4 "
				+ " AND HOUR(TIME(timeExit)) - HOUR(TIME(timeEnter)) > 3"); // condition
		query4.add("1"); // how many columns returned

		ArrayList<ArrayList<String>> queryData4 = MySQLConnection.select(query4);
		if (!(queryData4.get(0).get(0) == null)) {
			temp[3] = Double.parseDouble(queryData4.get(0).get(0));
			amountArrivedOverall += temp[3];
		} else
			temp[3] = 0;
		if (amountArrivedOverall != 0) {
			for (int i = 0; i < temp.length; i++) {
				answer.add((temp[i] / amountArrivedOverall) * 100);

			}
		} else
			answer.add("empty");

		// changed by Anastasia for testing proposes
		//EchoServer.sendToMyClient(answer, client);
		return answer;
	}

	/**
	 * Overall Visitors Report generated by visitors type. by parks with option for
	 * all parks. sends to client: Array list that contains: [1 to n] = Array list
	 * of string that contains: (n depends on number of entries in the DB) [0] =
	 * visitorType [1] = amount of visitors arrived on the specific dates
	 * 
	 * @param recived ArrayList of objects contains: [0] = String
	 *                "overallVisitorsReport", [1] = Array list of String contains:
	 *                [0] = String parkName, [1] = String startDate, [2] = String
	 *                endDate
	 * 
	 * @param client  ConnectionToClient
	 */

	@SuppressWarnings("unchecked")
	public static void OverallVisitorsReport(ArrayList<Object> recived, ConnectionToClient client) {

		ArrayList<Object> answer = new ArrayList<Object>();
		// the service name : getCancellationReports
		answer.add(recived.get(0));
		ArrayList<String> dataFromClient = (ArrayList<String>) recived.get(1);
		String startDate = dataFromClient.get(1);
		String endDate = dataFromClient.get(2);
		String dateCond = "arrivedTime BETWEEN '" + startDate + "' AND '" + endDate + "'";

		ArrayList<String> query = new ArrayList<String>();
		query.add("select"); // command
		query.add("orders"); // table name
		query.add("orderType, SUM(amountArrived), arrivedTime"); // columns to select from
		query.add("WHERE parkName='" + dataFromClient.get(0) + "' AND " + dateCond
				+ "AND amountArrived >0 GROUP BY DAY(arrivedTime), orderType"); // condition
		query.add("3"); // how many columns returned

		ArrayList<ArrayList<String>> queryData = MySQLConnection.select(query);
		if (queryData.isEmpty()) {
			// no orders in these dates
			answer.add(new ArrayList<String>(Arrays.asList("Failed")));
			EchoServer.sendToMyClient(answer, client);
			return;
		} else {
			answer.add(queryData);
			EchoServer.sendToMyClient(answer, client);
		}
	}

	/**
	 * report for When The Park Wasn't Full. send to client: Array list that
	 * contains: [0 to n] = Array list of string that contains: (n depends on number
	 * of entries in the DB) : [0] = date and time of a capsule that was not full,
	 * [1] = Difference between max allowed and actual arrived
	 * 
	 * @param recived ArrayList of objects contains: [0] = String "UsageReport", [1]
	 *                = Array list of String contains: [0] = String parkName, [1] =
	 *                String startDate , [2] = String endDate
	 * @param client  ConnectionToClient
	 */

	@SuppressWarnings("unchecked")
	public static void UsageReport(ArrayList<Object> recived, ConnectionToClient client) {
		ArrayList<String> dataFromClient = (ArrayList<String>) recived.get(1);
		ArrayList<Object> answer = new ArrayList<Object>();
		ArrayList<ArrayList<String>> notFullDaysTable = new ArrayList<ArrayList<String>>();
		answer.add(recived.get(0));
		String parkName = dataFromClient.get(0);
		String startDate = dataFromClient.get(1);
		String endDate = dataFromClient.get(2);
		String dateCond = "arrivedTime BETWEEN '" + startDate + "' AND '" + endDate + "'";
		ArrayList<String> query = new ArrayList<String>();
		query.add("select"); // select
		query.add("orders"); // tableName
		query.add("arrivedTime,SUM(amountArrived) AS amountArrived"); // columns
		query.add("WHERE parkName='" + parkName + "' AND " + dateCond + " GROUP BY arrivedTime ORDER BY arrivedTime"); // condition
		query.add("2"); // replyColNum
		ArrayList<ArrayList<String>> parkSummedCapacityByCapsule = MySQLConnection.select(query);
		query.clear();
		query.add("select"); // select
		query.add("park"); // tableName
		query.add("maxVisitorAmount"); // columns
		query.add("WHERE parkName= '" + parkName + "'"); // condition
		query.add("1"); // replyColNum

		ArrayList<ArrayList<String>> maxCapacityForPark = MySQLConnection.select(query);
		int maxCapacity = Integer.parseInt(maxCapacityForPark.get(0).get(0));
		for (ArrayList<String> row : parkSummedCapacityByCapsule) {
			double capacityInCapsule = Double.parseDouble(row.get(1));
			if (capacityInCapsule < maxCapacity) {
				ArrayList<String> notFullDaysRow = new ArrayList<String>();
				notFullDaysRow.add(row.get(0));
				String dif = "" + (maxCapacity - capacityInCapsule);
				notFullDaysRow.add(dif);
				notFullDaysTable.add(notFullDaysRow);
			}
		}

		answer.add(notFullDaysTable);
		try {
			client.sendToClient(answer);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/**
	 * Cancellation and visits lost Report. sends to client: ArrayList of Object:
	 * cell[0] func_name cell[1] ArrayList of String of rows in query
	 * 
	 * @param recived ArrayList Object: cell[0] name, cell[1] start date, cell[2]
	 *                end date
	 * @param client  ConnectionToClient
	 * 
	 */

	@SuppressWarnings("unchecked")
	public static void CancellationReport(ArrayList<Object> recived, ConnectionToClient client) {
		ArrayList<Object> answer = new ArrayList<Object>();
		// the service name : getCancellationReports
		answer.add(recived.get(0));

		ArrayList<String> dataFromClient = (ArrayList<String>) recived.get(1);
		String startDate = dataFromClient.get(0);
		String endDate = dataFromClient.get(1);
		String dateCond = "arrivedTime BETWEEN '" + startDate + "' AND '" + endDate + "'";
		ArrayList<String> query1 = new ArrayList<String>();
		query1.add("complexSelect"); // command
		query1.add(
				"(SELECT parkName, arrivedTime, visitorsNumber - amountArrived AS visitorsNumber FROM g9_gonature.orders WHERE "
						+ dateCond
						+ " AND visitorsNumber - amountArrived > 0 UNION ALL SELECT parkName, arrivedTime, visitorsNumber FROM g9_gonature.canceledorders WHERE "
						+ dateCond + " ORDER BY arrivedTime) t1 "); // table name
		query1.add("parkName, arrivedTime, SUM(visitorsNumber)"); // columns to present
		query1.add("GROUP BY Day(arrivedTime), parkname"); // condition
		query1.add("3"); // how many columns returned
		ArrayList<ArrayList<String>> queryData = MySQLConnection.select(query1);
		answer.add(queryData);
		EchoServer.sendToMyClient(answer, client);
	}

	/**
	 * sums the incomes on specific range of dates. sends to client ArrayList of
	 * Object: cell[0] func_name, cell[1] ArrayList of String cell[0] Date and time
	 * cell[1] amount of money earned
	 * 
	 * @param recived ArrayList of Object : cell[0] name, cell[1] ArrayList of
	 *                String cell[0] start date, cell[1] end date, cell[2] park name
	 * @param client  ConnectionToClient
	 * 
	 */

	@SuppressWarnings("unchecked")
	public static void incomesReport(ArrayList<Object> recived, ConnectionToClient client) {
		ArrayList<Object> answer = new ArrayList<Object>();
		answer.add(recived.get(0));
		String parkName = (String) ((ArrayList<String>) recived.get(1)).get(2);
		ArrayList<String> dataFromClient = (ArrayList<String>) recived.get(1);
		String startDate = dataFromClient.get(0);
		String endDate = dataFromClient.get(1);

		ArrayList<String> query = new ArrayList<String>();
		query.add("select");
		query.add("orders");
		query.add("arrivedTime, SUM(afterDiscountPrice) AS price");
		query.add("WHERE amountArrived>0 AND parkName='" + parkName + "' AND (arrivedTime BETWEEN '" + startDate
				+ "' AND '" + endDate + "') GROUP BY day(arrivedTime) order by day(arrivedTime) ");
		query.add("2");
		ArrayList<ArrayList<String>> queryData = MySQLConnection.select(query);
		answer.add(queryData);
		EchoServer.sendToMyClient(answer, client);

	}

}

//private static ISendToClient wrapSendToClient = new WrapSendToClient();

//public static class WrapSendToClient implements ISendToClient {
//
//	@Override
//	public void sendToMyClient(ArrayList<Object> answer, ConnectionToClient client) {
//		EchoServer.sendToMyClient(answer, client);
//	}
//
//}

//public Reports(ISendToClient wrapSendToClient) {
//	Reports.wrapSendToClient = wrapSendToClient;
//}
